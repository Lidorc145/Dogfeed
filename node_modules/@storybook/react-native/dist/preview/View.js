var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import React, { useEffect, useState, useReducer } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { toId } from '@storybook/csf';
import { addons } from '@storybook/addons';
import { ThemeProvider } from 'emotion-theming';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import OnDeviceUI from './components/OnDeviceUI';
import { theme } from './components/Shared/theme';
import StoryView from './components/StoryView';
import createChannel from '@storybook/channel-websocket';
import getHost from './rn-host-detect';
import events from '@storybook/core-events';
const STORAGE_KEY = 'lastOpenedStory';
export class View {
    constructor(preview) {
        this._setStory = () => { };
        this._ready = false;
        this._getInitialStory = ({ initialSelection, shouldPersistSelection = true, } = {}) => __awaiter(this, void 0, void 0, function* () {
            if (initialSelection) {
                if (typeof initialSelection === 'string') {
                    return { storySpecifier: initialSelection, viewMode: 'story' };
                }
                else {
                    return {
                        storySpecifier: toId(initialSelection.kind, initialSelection.name),
                        viewMode: 'story',
                    };
                }
            }
            if (shouldPersistSelection) {
                try {
                    let value = this._asyncStorageStoryId;
                    if (!value) {
                        value = yield AsyncStorage.getItem(STORAGE_KEY);
                        this._asyncStorageStoryId = value;
                    }
                    return { storySpecifier: value !== null && value !== void 0 ? value : '*', viewMode: 'story' };
                }
                catch (e) {
                    console.warn('storybook-log: error reading from async storage', e);
                }
            }
            return { storySpecifier: '*', viewMode: 'story' };
        });
        this._getServerChannel = (params = {}) => {
            const host = getHost(params.host || 'localhost');
            const port = `:${params.port || 7007}`;
            const query = params.query || '';
            const websocketType = params.secured ? 'wss' : 'ws';
            const url = `${websocketType}://${host}${port}/${query}`;
            return createChannel({
                url,
                async: true,
                onError: () => __awaiter(this, void 0, void 0, function* () { }),
            });
        };
        this.getStorybookUI = (params = {}) => {
            const { shouldPersistSelection = true, onDeviceUI = true, enableWebsockets = false } = params;
            const initialStory = this._getInitialStory(params);
            if (enableWebsockets) {
                const channel = this._getServerChannel(params);
                addons.setChannel(channel);
                // TODO: check this with someone who knows what they're doing
                this._preview.channel = channel;
                this._preview.setupListeners();
                channel.emit(events.CHANNEL_CREATED);
                this._preview.initializeWithStoryIndex(this._storyIndex);
            }
            addons.loadAddons({
                store: () => ({
                    fromId: (id) => this._preview.storyStore.getStoryContext(this._preview.storyStore.fromId(id)),
                    getSelection: () => {
                        return this._preview.currentSelection;
                    },
                    _channel: this._preview.channel,
                }),
            });
            // eslint-disable-next-line consistent-this
            const self = this;
            const appliedTheme = Object.assign(Object.assign({}, theme), params.theme);
            return () => {
                const [context, setContext] = useState();
                const [, forceUpdate] = useReducer((x) => x + 1, 0);
                useEffect(() => {
                    self._setStory = (newStory) => {
                        setContext(newStory);
                        if (shouldPersistSelection) {
                            AsyncStorage.setItem(STORAGE_KEY, newStory.id).catch((e) => {
                                console.warn('storybook-log: error writing to async storage', e);
                            });
                        }
                    };
                    self._forceRerender = () => forceUpdate();
                    initialStory.then((story) => {
                        self._preview.urlStore.selectionSpecifier = story;
                        self._preview.selectSpecifiedStory();
                    });
                }, []);
                if (onDeviceUI) {
                    return (React.createElement(SafeAreaProvider, null,
                        React.createElement(ThemeProvider, { theme: appliedTheme },
                            React.createElement(OnDeviceUI, { context: context, storyIndex: self._storyIndex, isUIHidden: params.isUIHidden, tabOpen: params.tabOpen, shouldDisableKeyboardAvoidingView: params.shouldDisableKeyboardAvoidingView, keyboardAvoidingViewVerticalOffset: params.keyboardAvoidingViewVerticalOffset }))));
                }
                else {
                    return React.createElement(StoryView, { context: context });
                }
            };
        };
        this._preview = preview;
    }
}
