{"version":3,"names":[],"sources":["types.tsx"],"sourcesContent":["import type {\n  HeaderBackButton,\n  HeaderBackButtonProps,\n  HeaderButtonProps,\n  HeaderOptions,\n  HeaderTitleProps,\n} from '@react-navigation/elements';\nimport type {\n  Descriptor,\n  NavigationHelpers,\n  NavigationProp,\n  ParamListBase,\n  Route,\n  RouteProp,\n  StackActionHelpers,\n  StackNavigationState,\n} from '@react-navigation/native';\nimport type * as React from 'react';\nimport type { Animated, StyleProp, TextStyle, ViewStyle } from 'react-native';\n\nexport type StackNavigationEventMap = {\n  /**\n   * Event which fires when a transition animation starts.\n   */\n  transitionStart: { data: { closing: boolean } };\n  /**\n   * Event which fires when a transition animation ends.\n   */\n  transitionEnd: { data: { closing: boolean } };\n  /**\n   * Event which fires when navigation gesture starts.\n   */\n  gestureStart: { data: undefined };\n  /**\n   * Event which fires when navigation gesture is completed.\n   */\n  gestureEnd: { data: undefined };\n  /**\n   * Event which fires when navigation gesture is canceled.\n   */\n  gestureCancel: { data: undefined };\n};\n\nexport type StackNavigationHelpers = NavigationHelpers<\n  ParamListBase,\n  StackNavigationEventMap\n> &\n  StackActionHelpers<ParamListBase>;\n\nexport type StackNavigationProp<\n  ParamList extends ParamListBase,\n  RouteName extends keyof ParamList = keyof ParamList,\n  NavigatorID extends string | undefined = undefined\n> = NavigationProp<\n  ParamList,\n  RouteName,\n  NavigatorID,\n  StackNavigationState<ParamList>,\n  StackNavigationOptions,\n  StackNavigationEventMap\n> &\n  StackActionHelpers<ParamList>;\n\nexport type StackScreenProps<\n  ParamList extends ParamListBase,\n  RouteName extends keyof ParamList = keyof ParamList,\n  NavigatorID extends string | undefined = undefined\n> = {\n  navigation: StackNavigationProp<ParamList, RouteName, NavigatorID>;\n  route: RouteProp<ParamList, RouteName>;\n};\n\nexport type Layout = { width: number; height: number };\n\nexport type GestureDirection =\n  | 'horizontal'\n  | 'horizontal-inverted'\n  | 'vertical'\n  | 'vertical-inverted';\n\ntype SceneOptionsDefaults = TransitionPreset & {\n  animationEnabled: boolean;\n  gestureEnabled: boolean;\n  cardOverlayEnabled: boolean;\n  headerMode: StackHeaderMode;\n};\n\nexport type Scene = {\n  /**\n   * Route object for the current screen.\n   */\n  route: Route<string>;\n  /**\n   * Descriptor object for the screen.\n   */\n  descriptor: Omit<StackDescriptor, 'options'> & {\n    options: Omit<StackDescriptor['options'], keyof SceneOptionsDefaults> &\n      SceneOptionsDefaults;\n  };\n  /**\n   * Animated nodes representing the progress of the animation.\n   */\n  progress: SceneProgress;\n};\n\nexport type SceneProgress = {\n  /**\n   * Progress value of the current screen.\n   */\n  current: Animated.AnimatedInterpolation;\n  /**\n   * Progress value for the screen after this one in the stack.\n   * This can be `undefined` in case the screen animating is the last one.\n   */\n  next?: Animated.AnimatedInterpolation;\n  /**\n   * Progress value for the screen before this one in the stack.\n   * This can be `undefined` in case the screen animating is the first one.\n   */\n  previous?: Animated.AnimatedInterpolation;\n};\n\nexport type StackHeaderMode = 'float' | 'screen';\n\nexport type StackPresentationMode = 'card' | 'modal';\n\nexport type StackHeaderOptions = Omit<\n  HeaderOptions,\n  'headerLeft' | 'headerTitle' | 'headerRight'\n> & {\n  /**\n   * String or a function that returns a React Element to be used by the header.\n   * Defaults to screen `title` or route name.\n   *\n   * It receives `allowFontScaling`, `tintColor`, `style` and `children` in the options object as an argument.\n   * The title string is passed in `children`.\n   */\n  headerTitle?: string | ((props: HeaderTitleProps) => React.ReactNode);\n  /**\n   * Function which returns a React Element to display on the left side of the header.\n   */\n  headerLeft?: (props: HeaderBackButtonProps) => React.ReactNode;\n  /**\n   * Function which returns a React Element to display on the right side of the header.\n   */\n  headerRight?: (props: HeaderButtonProps) => React.ReactNode;\n  /**\n   * Whether back button title font should scale to respect Text Size accessibility settings. Defaults to `false`.\n   */\n  headerBackAllowFontScaling?: boolean;\n  /**\n   * Accessibility label for the header back button.\n   */\n  headerBackAccessibilityLabel?: string;\n  /**\n   * ID to locate this back button in tests.\n   */\n  headerBackTestID?: string;\n  /**\n   * Title string used by the back button on iOS.\n   * Defaults to the previous screen's title, or \"Back\" if there's not enough space.\n   * Use `headerBackTitleVisible: false` to hide it.\n   */\n  headerBackTitle?: string;\n  /**\n   * Whether the back button title should be visible or not.\n   *\n   * Defaults to `true` on iOS, `false on Android.\n   */\n  headerBackTitleVisible?: boolean;\n  /**\n   * Style object for the back title.\n   */\n  headerBackTitleStyle?: StyleProp<TextStyle>;\n  /**\n   * Title string used by the back button when `headerBackTitle` doesn't fit on the screen. `\"Back\"` by default.\n   */\n  headerTruncatedBackTitle?: string;\n  /**\n   * Function which returns a React Element to display custom image in header's back button.\n   * It receives the `tintColor` in in the options object as an argument. object.\n   * Defaults to Image component with a the default back icon image for the platform (a chevron on iOS and an arrow on Android).\n   */\n  headerBackImage?: React.ComponentProps<typeof HeaderBackButton>['backImage'];\n};\n\nexport type StackHeaderProps = {\n  /**\n   * Layout of the screen.\n   */\n  layout: Layout;\n  /**\n   * Options for the back button.\n   */\n  back?: {\n    /**\n     * Title of the previous screen.\n     */\n    title: string;\n  };\n  /**\n   * Animated nodes representing the progress of the animation.\n   */\n  progress: SceneProgress;\n  /**\n   * Options for the current screen.\n   */\n  options: StackNavigationOptions;\n  /**\n   * Route object for the current screen.\n   */\n  route: Route<string>;\n  /**\n   * Navigation prop for the header.\n   */\n  navigation: StackNavigationProp<ParamListBase>;\n  /**\n   * Interpolated styles for various elements in the header.\n   */\n  styleInterpolator: StackHeaderStyleInterpolator;\n};\n\nexport type StackDescriptor = Descriptor<\n  StackNavigationOptions,\n  StackNavigationProp<ParamListBase>,\n  RouteProp<ParamListBase>\n>;\n\nexport type StackDescriptorMap = Record<string, StackDescriptor>;\n\nexport type StackNavigationOptions = StackHeaderOptions &\n  Partial<TransitionPreset> & {\n    /**\n     * String that can be displayed in the header as a fallback for `headerTitle`.\n     */\n    title?: string;\n    /**\n     * Function that given `HeaderProps` returns a React Element to display as a header.\n     */\n    header?: (props: StackHeaderProps) => React.ReactNode;\n    /**\n     * Whether the header floats above the screen or part of the screen.\n     * Defaults to `float` on iOS for non-modals, and `screen` for the rest.\n     */\n    headerMode?: StackHeaderMode;\n    /**\n     * Whether to show the header. The header is shown by default.\n     * Setting this to `false` hides the header.\n     */\n    headerShown?: boolean;\n    /**\n     * Whether a shadow is visible for the card during transitions. Defaults to `true`.\n     */\n    cardShadowEnabled?: boolean;\n    /**\n     * Whether to have a semi-transparent dark overlay visible under the card during transitions.\n     * Defaults to `true` on Android and `false` on iOS.\n     */\n    cardOverlayEnabled?: boolean;\n    /**\n     * Function that returns a React Element to display as a overlay for the card.\n     */\n    cardOverlay?: (props: {\n      style: Animated.WithAnimatedValue<StyleProp<ViewStyle>>;\n    }) => React.ReactNode;\n    /**\n     * Style object for the card in stack.\n     * You can provide a custom background color to use instead of the default background here.\n     *\n     * You can also specify `{ backgroundColor: 'transparent' }` to make the previous screen visible underneath.\n     * This is useful to implement things like modal dialogs.\n     *\n     * You should also specify `detachPreviousScreen: false` in options when using a transparent background\n     * so that the previous screen isn't detached and stays below the current screen.\n     *\n     * You might also need to change the animation of the screen using `cardStyleInterpolator`\n     * so that the previous screen isn't transformed or invisible.\n     */\n    cardStyle?: StyleProp<ViewStyle>;\n    /**\n     * Whether this screen should be presented as a modal or a regular card.\n     *\n     * Specifying this will configure several options:\n     * - `card`: Use the default OS animations for iOS and Android screen transitions.\n     * - `modal`: Use Modal animations. This changes a few things:\n     *   - Sets `headerMode` to `screen` for the screen unless specified otherwise.\n     *   - Changes the screen animation to match the platform behavior for modals.\n     * - `transparentModal`: Similar to `modal`. This changes following things:\n     *   - Sets `headerMode` to `screen` for the screen unless specified otherwise.\n     *   - Sets background color of the screen to transparent, so previous screen is visible\n     *   - Adjusts the `detachPreviousScreen` option so that the previous screen stays rendered.\n     *   - Prevents the previous screen from animating from its last position.\n     *   - Changes the screen animation to a vertical slide animation.\n     *\n     * Defaults to 'card'.\n     */\n    presentation?: 'card' | 'modal' | 'transparentModal';\n    /**\n     * Whether transition animation should be enabled the screen.\n     * If you set it to `false`, the screen won't animate when pushing or popping.\n     * Defaults to `true` on Android and iOS, `false` on Web.\n     */\n    animationEnabled?: boolean;\n    /**\n     * The type of animation to use when this screen replaces another screen. Defaults to `push`.\n     * When `pop` is used, the `pop` animation is applied to the screen being replaced.\n     */\n    animationTypeForReplace?: 'push' | 'pop';\n    /**\n     * Whether you can use gestures to dismiss this screen. Defaults to `true` on iOS, `false` on Android.\n     * Not supported on Web.\n     */\n    gestureEnabled?: boolean;\n    /**\n     * Distance of touch start from the edge of the screen to recognize gestures.\n     * Not supported on Web.\n     */\n    gestureResponseDistance?: number;\n    /**\n     * Number which determines the relevance of velocity for the gesture. Defaults to 0.3.\n     * Not supported on Web.\n     */\n    gestureVelocityImpact?: number;\n    /**\n     * Whether to detach the previous screen from the view hierarchy to save memory.\n     * Set it to `false` if you need the previous screen to be seen through the active screen.\n     * Only applicable if `detachInactiveScreens` isn't set to `false`.\n     * Defaults to `false` for the last screen for modals, otherwise `true`.\n     */\n    detachPreviousScreen?: boolean;\n    /**\n     * If `false`, the keyboard will NOT automatically dismiss when navigating to a new screen from this screen.\n     * Defaults to `true`.\n     */\n    keyboardHandlingEnabled?: boolean;\n    /**\n     * Whether inactive screens should be suspended from re-rendering. Defaults to `false`.\n     * Defaults to `true` when `enableFreeze()` is run at the top of the application.\n     * Requires `react-native-screens` version >=3.16.0.\n     *\n     * Only supported on iOS and Android.\n     */\n    freezeOnBlur?: boolean;\n  };\n\nexport type StackNavigationConfig = {\n  /**\n   * Whether inactive screens should be detached from the view hierarchy to save memory.\n   * This will have no effect if you disable `react-native-screens`.\n   *\n   * Defaults to `true`.\n   */\n  detachInactiveScreens?: boolean;\n};\n\nexport type TransitionSpec =\n  | {\n      animation: 'spring';\n      config: Omit<\n        Animated.SpringAnimationConfig,\n        'toValue' | keyof Animated.AnimationConfig\n      >;\n    }\n  | {\n      animation: 'timing';\n      config: Omit<\n        Animated.TimingAnimationConfig,\n        'toValue' | keyof Animated.AnimationConfig\n      >;\n    };\n\nexport type StackCardInterpolationProps = {\n  /**\n   * Values for the current screen.\n   */\n  current: {\n    /**\n     * Animated node representing the progress value of the current screen.\n     */\n    progress: Animated.AnimatedInterpolation;\n  };\n  /**\n   * Values for the screen after this one in the stack.\n   * This can be `undefined` in case the screen animating is the last one.\n   */\n  next?: {\n    /**\n     * Animated node representing the progress value of the next screen.\n     */\n    progress: Animated.AnimatedInterpolation;\n  };\n  /**\n   * The index of the card with this interpolation in the stack.\n   */\n  index: number;\n  /**\n   * Animated node representing whether the card is closing (1 - closing, 0 - not closing).\n   */\n  closing: Animated.AnimatedInterpolation;\n  /**\n   * Animated node representing whether the card is being swiped (1 - swiping, 0 - not swiping).\n   */\n  swiping: Animated.AnimatedInterpolation;\n  /**\n   * Animated node representing multiplier when direction is inverted (-1 - inverted, 1 - normal).\n   */\n  inverted: Animated.AnimatedInterpolation;\n  /**\n   * Layout measurements for various items we use for animation.\n   */\n  layouts: {\n    /**\n     * Layout of the whole screen.\n     */\n    screen: Layout;\n  };\n  /**\n   * Safe area insets\n   */\n  insets: {\n    top: number;\n    right: number;\n    bottom: number;\n    left: number;\n  };\n};\n\nexport type StackCardInterpolatedStyle = {\n  /**\n   * Interpolated style for the container view wrapping the card.\n   */\n  containerStyle?: any;\n  /**\n   * Interpolated style for the view representing the card.\n   */\n  cardStyle?: any;\n  /**\n   * Interpolated style for the view representing the semi-transparent overlay below the card.\n   */\n  overlayStyle?: any;\n  /**\n   * Interpolated style representing the card shadow.\n   */\n  shadowStyle?: any;\n};\n\nexport type StackCardStyleInterpolator = (\n  props: StackCardInterpolationProps\n) => StackCardInterpolatedStyle;\n\nexport type StackHeaderInterpolationProps = {\n  /**\n   * Values for the current screen (the screen which owns this header).\n   */\n  current: {\n    /**\n     * Animated node representing the progress value of the current screen.\n     */\n    progress: Animated.AnimatedInterpolation;\n  };\n  /**\n   * Values for the screen after this one in the stack.\n   * This can be `undefined` in case the screen animating is the last one.\n   */\n  next?: {\n    /**\n     * Animated node representing the progress value of the next screen.\n     */\n    progress: Animated.AnimatedInterpolation;\n  };\n  /**\n   * Layout measurements for various items we use for animation.\n   */\n  layouts: {\n    /**\n     * Layout of the header\n     */\n    header: Layout;\n    /**\n     * Layout of the whole screen.\n     */\n    screen: Layout;\n    /**\n     * Layout of the title element.\n     */\n    title?: Layout;\n    /**\n     * Layout of the back button label.\n     */\n    leftLabel?: Layout;\n  };\n};\n\nexport type StackHeaderInterpolatedStyle = {\n  /**\n   * Interpolated style for the label of the left button (back button label).\n   */\n  leftLabelStyle?: any;\n  /**\n   * Interpolated style for the left button (usually the back button).\n   */\n  leftButtonStyle?: any;\n  /**\n   * Interpolated style for the right button.\n   */\n  rightButtonStyle?: any;\n  /**\n   * Interpolated style for the header title text.\n   */\n  titleStyle?: any;\n  /**\n   * Interpolated style for the header background.\n   */\n  backgroundStyle?: any;\n};\n\nexport type StackHeaderStyleInterpolator = (\n  props: StackHeaderInterpolationProps\n) => StackHeaderInterpolatedStyle;\n\nexport type TransitionPreset = {\n  /**\n   * The direction of swipe gestures, `horizontal` or `vertical`.\n   */\n  gestureDirection: GestureDirection;\n  /**\n   * Object which specifies the animation type (timing or spring) and their options (such as duration for timing).\n   */\n  transitionSpec: {\n    /**\n     * Transition configuration when adding a screen.\n     */\n    open: TransitionSpec;\n    /**\n     * Transition configuration when removing a screen.\n     */\n    close: TransitionSpec;\n  };\n  /**\n   * Function which specifies interpolated styles for various parts of the card, e.g. the overlay, shadow etc.\n   */\n  cardStyleInterpolator: StackCardStyleInterpolator;\n  /**\n   * Function which specifies interpolated styles for various parts of the header, e.g. the title, left button etc.\n   */\n  headerStyleInterpolator: StackHeaderStyleInterpolator;\n};\n"],"mappings":""}